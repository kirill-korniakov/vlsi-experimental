params:
{
    objective = "LSE";
    target_clock_cycle = 0.0;

    techname = "IWLS"; //default
    //techname = "NangateMapped"; //with technology mapping
    //techname = "Nangate";       //without technology mapping
    //techname = "ISPD";

    //def = "../../Benchmarks/IWLS_GP_r1511/IWLS_GP_007161_tv80.def";
    //def = "../../Benchmarks/IWLS05/ac97_ctrl.def";
    def = "../../Benchmarks/IWLS05/tv80.def";
    //def = "../../Benchmarks/IWLS05/s298.def";
};

plotter:
{
    //enabled = true;
    windowHeight = 800;
    histogramWindowHeight = 300;
    histogramWindowWidth = 1200;
    autoRefreshStep = 10;
    saveImages = true;
    saveMilestoneImages = true;
    embeedMilestones = true;
    createVideo = true;
    pixDirectory = ".\\pix\\";
};

DesignFlow:
{
    //PRE-RUN SECTION
    SkipSpecialNets = true;
    SkipBrokenNets = true;

    //MACRO LOOP SECTION
    nMacroIterations = 0;
    //LoopRandomPlacement = true;
    //LoopGlobalPlacement = true;
    //LoopLR          = true;
    //LoopLegalization = true;
    //LoopDetailedPlacement = true;
    //LoopBuffering = true;
    //LoopRemoveNewBuffering = true;
    //LoopNew_Buffering = true;
    //LoopBufRandomPlacement = true;
    //LoopBufGlobalPlacement = true;
    //LoopBufLR          = true;
    //LoopBufLegalization = true;
    //LoopBufDetailedPlacement = true;

    //STANDARD PLACEMENT SECTION
    //RandomPlacement = true;
    GlobalPlacement = true;
    //LR          = true;
    //Legalization = true;
    //DetailedPlacement = true;
    //HippocratePlacement = true;
    //LRSizing = true;

    //REPEATERS INSERTION SECTION
    //Buffering = true;
    New_Buffering = true;
    //BufRandomPlacement = true;
    //BufGlobalPlacement = true;
    //BufLR          = true;
    BufLegalization = true;
    //BufDetailedPlacement = true;

    //MISCELLANEOUS
    //DrawCongestionMap = true; //needs testing
    //FGRRouting = true;
};

MacroLoop:
{
    QAcriteria = "LHPWL";
    LSE:
    {
        Clustering:
        {
            useClusteringInformationFromFile  = false;
        };
    };
};

LSE:
{
  Clustering:
  {
    useClusteringInformationFromFile  = true;
    //deleteDuplicatingNets             = true;
  };



GlobalPlacement:
{    
    randSeed = 51117;
    batchSizeForvdExp = 1000;
    bufferName = "BUF_ITL";
    bufferCountUpperBound = 0.0; //set to 0 if you want to disable joint algorithm

    placeToTheCenter = true;
    shufflePercent = 0.0;

    useQAClass = true;
    QAcriteria = "LHPWL";
    earlyExit = true;
    improvementTreshold = -0.00; //-0.01 means 1% improvement decrease allowed
    nTolerantIterations = 3;
    nConvergedIterations = 2;

    useLogSumExp = true;
    useSumOfDelays = false;
    useLR = false;
    useSpreading = true;
    useUnidirectSpreading = true;  //used only with useSpreading = true 
    useBorderBounds = true;

    Weights:
    {
        lseInitialRatio = 1.0;
        lrInitialRatio = 1.0;
        sprInitialRatio = 0.1;

        lseDesiredRatio = 1.0;
        sprDesiredRatio = 1.1;

        lseUpdateMultiplier = 2.0;
        lrUpdateMultiplier = 2.0;
        sprUpdateMultiplier = 1.8;
    };

    alphaMultiplier = 0.5;
    potentialRatio = 2.1; //must be greater than 0.5

    LagrangianRelaxation:
    {
        muLR     = 0.5;

        theta    = 1.1;
        minFactor = 0.01;
        referenceValue = 100;

        Reporter:
        {
            verbose = false;
            plotMus = false;
            order = "CriticalPath"; //"Topological"
        };
    };

    TAOOptions:
    {
        commandLine               = ""; //-tao_monitor
        method                    = "tao_blmvm";
        nOuterIterations          = 100;
        nInnerIterations          = 100;

        fatol = 1.0e-14;
        frtol = 1.0e-14;
        catol = 1.0e-8;
        crtol = 1.0e-8;
    };

    Plotting:
    {
        plotWires = false;
        plotSolverState = false;
        saveTAOmilestones = false;
        plotWait        = 1;
        gradientScaling = 1000.0;
    };

    UseBuffering = true;
	New_Buffering:
    {
        DefaultBuffer:
        {
            Macro="BUF_ITL";
            InputPin = "A";
            OutputPin = "Y";
        };
        UseOnlyDefaultBuffer = true;
        BufferList = "BUF_ITL,BUF_INVX1,BUF_INVX4,BUF_INVX8";
        TypePartition = 0; //0 - обычное линейное разбиение, 1 - динамическое распределение точек, //
                           //2 - легальное распределение точек (использовать только с 1 или 2 типом буферизации)
        IsInsertInSourceAndSink = true;
        BufferListLength = 4;
        Interval = 20;
        TypeBufferingAlgorithm = 1; //0 - рекурсивный обход дерева, 1 - линейный обход дерева, 
								    //2 - линейный обход дерева и измененное вычисление длин ребер(TO DO: ПРИДУМАТЬ НОРМАЛЬНУЮ ФОРМУЛИРОВКУ)
	      MaxBufferCount = 0; //если равен 0 то нет ограничений на количество вставляемых буферов,
        TypeModificationVanGinnekenList = 0; //0 - классические правила формирования и изменения списка вариантов,
                                             //1 - количество вставляемых буферов ограничено MaxBufferCount
                                             //2 - полный перебор вариантов
        CountPinInBufferingInterconnection = 0; //если равен 0 то нет ограничений
        IsNotExactPinCountRequired = true;
        NameBufferingNet = "";//"From    i_tv80_core_BusA_reg\\[2\\]Q    To    i_tv80_core_i_reg_RegsL_reg[7]\\[7\\]D";//"n_4755";
        TypeBufferAddition = 0; //0 - оьычная вставка буферов, 1 - вставка с легализацией
        SizeBufferMultiplier = 1.0; //0.5313443074;//0.102;
        AdaptiveSizeBufferMultiplier = true;
        IsNetContainPrimaryPin = true;
        TotalAllowableBuffersArea = 0; //0 - буферизация без ограничения, 1 - площадь буферов совпадает с площадью буферов
        TypeNetListBuffering = 1; //0 - буферизация нетов входящих в все критические пути; 1 - PathBased
        ReRoutingSteinerTree = true;
        MaxCountRepeatNet = 0;
        LimitationCountCriticalPath = 4; //означает что будет произведено итераций буферизации не более чем CriticalPaths.Count() * LimitationCountCriticalPath, 0 - буферизуем до конца;
        NumberBufferedAtOnceCriticalPaths = 1;
        NumberMetaIterationStartBuffering = 0;//начиная с какой итерации кластеризации начнет работать буферизация в совместном алгоритме

        Legalization:
        {
            doReport = false;
        };

        Plotting:
        {
            PlotSteinerPoint = false;
            PlotVGTree = false;
            PlotNets = false;
            PlotBuffer = false;
	        PlotBinGridValue = false;
            PlotterWaitTime = 1;
        };

        Reporting:
        {
            reportParameters = true;
            reportBufferInfo = false;

            PrintNetInfo = false;
            PrintVGVariantsList = false;
            PrintCriticalPathsInfo = false;
            PrintTimingAfterBufferingCriticalPaths = false;
            PrintSumPutencial = false;            
        };
    };
	
	PQAT:
	{
		showPercents = false;
		Columns = ["Objective", "ObHPWL", "ObLR", "ObSpr", "gHPWL", "gLR", "gSpr", "HPWL", "LHPWL", "TNS", "LTNS", "WNS", "LWNS"];
	};
};
};

DetailedPlacement:
{
    HorizontalSearch:
    {
        active = true;
        plotter: {enabled = false;};
    };

    GlobalSwap:
    {
        active = true;
        plotter: {enabled = false;};
    };

    VerticalSearch:
    {
        active = true;
        plotter: {enabled = false;};
    };

    useConstraints = false;
};

HippocratePlacement:
{
    //	SWAP = true;
    MOVE =  true;
    LOCALMOVE = true;
    COMPACT = true;
    CENTER = true;

    KamaevCheckConstraints = true;

    PathsInCriticalOrder = true;

    LogEveryIteration=true;
    FindOnlyInsideGaps = true; //COMPACT
};

Timing:
{
    SignalDirectionsUsed = 1; //rise\fall
    RCE:
    {
        LayersUsed = 0;//0 - lumped (=1 with simplified C extraction), 1 or 2, 3=Hippocrate
    };
};

CriticalPaths:
{
    countLogReportCriticalPaths = 0;  //set to -1 if you want to print all the critical paths
    countPlotCriticalPaths = 0;       //set to -1 if you want to plot all the critical paths
    plotWait = 1;
};

NetWeighting:
{
    useNetWeights = true;
    netWeightsImportFileName = "";
    netWeightsExportFileName = "";
    method = "APlace";
    //method = "SensitivityGuidedNetWeighting";
    normalize = false;

    APlace:
    {
        u    = 0.3;
        beta = 2.0;
        aggregationMethod = "sum";
    };
    SensitivityGuidedNetWeighting:
    {
        minWeight = 1.0;
        alpha     = 0.6;
        C         = 3227.0;
    };
};

Legalization:
{
    Abacus:
    {
        //usePlotter = true;
        plotterStep = 100;
        //useWeights = true;
        weightMultiplier = 1;
    };
};

Buffering:
{
    DefaultBuffer:
    {
        Macro="BUF_ITL";
        InputPin = "A";
        OutputPin = "Y";
    };
    Percent = 1.00;
    Iterations = 15;
    DoIterative = false;

    Legalization:
    {
        doReport = false;
    };
};

CongestionMap:
{
    nHorTiles  = 30;
    nVertTiles = 30;
    nMaxLines  = 10; //all wires
    nMaxCLines = 4; //critical wires
    nMaxPins   = 10;
};

FGRRouting:
{
    maxRoutingTime        = 86400; //max time to work in seconds
    calculateCapacity     = true;  //use (or not) formula to calculate capacity
    powerTracsPerRow      = 2;
    verticalCapacity      = 20;
    horizontalCapacity    = 20;
    nHorTiles             = 0; //if 0 then
    nVertTiles            = 0; //nHorTiles == nVertTiles == nRows / 2
    FGROutputFile         = "res.fgr";
    ImageSize             = 900; //horizontal and vertical number of pixels in the XPM file
    PrintToRoutersFormats = false;
    ISPDFileName          = "@params.def";
    LabyrinthFileName     = "@params.def";
};

Config:
{
    //Trace = true;
    Replicate = true;
    WarnOnChange = true;
};

New_Buffering:
{
    DefaultBuffer:
    {
        Macro="BUF_ITL";
        InputPin = "A";
        OutputPin = "Y";
    };
    UseOnlyDefaultBuffer = true;
    BufferList = "BUF_ITL,BUF_INVX1,BUF_INVX4,BUF_INVX8";
    TypePartition = 0; //0 - обычное линейное разбиение, 1 - динамическое распределение точек, //
                       //2 - легальное распределение точек (использовать только с 1 или 2 типом буферизации)
    IsInsertInSourceAndSink = true;
    BufferListLength = 4;
    Interval = 20;
    TypeBufferingAlgorithm = 1; //0 - рекурсивный обход дерева, 1 - линейный обход дерева, 
								//2 - линейный обход дерева и измененное вычисление длин ребер(TO DO: ПРИДУМАТЬ НОРМАЛЬНУЮ ФОРМУЛИРОВКУ)
	  MaxBufferCount = 0; //если равен 0 то нет ограничений на количество вставляемых буферов,
    TypeModificationVanGinnekenList = 0; //0 - классические правила формирования и изменения списка вариантов,
                                         //1 - количество вставляемых буферов ограничено MaxBufferCount
                                         //2 - полный перебор вариантов
    CountPinInBufferingInterconnection = 0; //если равен 0 то нет ограничений
    IsNotExactPinCountRequired = true;
    NameBufferingNet = "";//"From    i_tv80_core_BusA_reg\\[2\\]Q    To    i_tv80_core_i_reg_RegsL_reg[7]\\[7\\]D";//"n_4755";
    TypeBufferAddition = 0; //0 - оьычная вставка буферов, 1 - вставка с легализацией
    SizeBufferMultiplier = 1.0; //0.5313443074;//0.102;
    AdaptiveSizeBufferMultiplier = false;
    IsNetContainPrimaryPin = true;
    TotalAllowableBuffersArea = 0; //0 - буферизация без ограничения, 1 - площадь буферов совпадает с площадью буферов
    TypeNetListBuffering = 1; //0 - буферизация нетов входящих в все критические пути; 1 - PathBased
    ReRoutingSteinerTree = true;
    MaxCountRepeatNet = 0;
    LimitationCountCriticalPath = 4; //означает что будет произведено итераций буферизации не более чем CriticalPaths.Count() * LimitationCountCriticalPath, 0 - буферизуем до конца;
    NumberBufferedAtOnceCriticalPaths = 1;

    Legalization:
    {
        doReport = false;
    };

    Plotting:
    {
        PlotSteinerPoint = false;
        PlotVGTree = false;
        PlotNets = false;
        PlotBuffer = false;
	    PlotBinGridValue = false;
        PlotterWaitTime = 1;
    };

    Reporting:
    {
        reportParameters = true;
        reportBufferInfo = false;

        PrintNetInfo = false;
        PrintVGVariantsList = false;
        PrintCriticalPathsInfo = false;
        PrintTimingAfterBufferingCriticalPaths = false;
        
    };
};